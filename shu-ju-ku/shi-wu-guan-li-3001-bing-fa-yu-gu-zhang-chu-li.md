# 事务管理

> 5.1	事务处理（概念）
> * 事务的定义与ACID性质
> * 事务活动及其状态转换图
> * 事务控制及相关的参数设置语句：事务的提交与回滚，事务的读/写类型与隔离级别
> * 事务的语句组成成分
> 5.2	并发控制技术（概念）
> * 事务
>   * 事务的并发性，并发控制
>   * 调度，串行调度，可串行化调度，冲突与冲突可串行化，视图可串行化
>   * 冲突可串行化的判定方法
>   * 不正确的事务并发所导致的数据不一致现象：丢失修改lost-update，脏读dirty-read，不可重复读unrepeatable-read
> * 封锁
>   * 共享锁（S锁），排它锁（X锁），锁相容矩阵，锁申请/锁释放算法
>   * 基于封锁技术的并发控制实现方法
>       * 三级封锁协议，三级封锁协议与数据不一致现象之间的关系
>       * 两阶段封锁协议
>       * 两阶段封锁协议与冲突可串行化的关系
> * 多粒度封锁
>   * 封锁粒度/并发度/并发控制实现开销 之间的关系
>   * 多粒度树，多粒度封锁
>   * 基于意向锁的多粒度封锁协议
>       * 意向锁：IS, IX, SIX
>       * 意向锁锁相容矩阵：S，X，IS, IX, SIX
>       * 意向锁锁申请算法，意向锁锁释放算法
> * 死锁的检测与预防
>   * 死锁 & 活锁
>   * 死锁的检测及其处理办法
>       * 等待图法
>       * 超时死锁检测法：锁申请等待超时 & 事务执行超时
>       * 时间戳死锁检测法
> 5.3	数据库恢复技术
> * 数据库恢复的含义、方法和常用措施
> * 数据库故障的分类
> * 数据库故障恢复三大技术：数据转储，日志，数据库镜像
> * 数据转储：静态转储/动态转储，海量转储/增量转储，
> * 日志：
>   * 日志的内容、组成、作用与记载原则
>   * 在日志中设置检查点的作用
>   * 事务的撤销（UNDO）与重做（REDO）
>   * UNDO日志
>       * UNDO日志的内容，记载规则，作用
>       * 基于UNDO日志的故障恢复流程
>   * REDO日志
>       * REDO日志的内容，记载规则，作用
>       * 基于REDO日志的故障恢复流程
>   * UNDO/REDO日志
>       * UNDO/REDO日志的内容，记载规则，作用
>       * 基于UNDO/REDO日志的故障恢复流程
>   * UNDO日志、REDO日志、UNDO/REDO日志的优点与缺点
> * 恢复策略：小型/中型/大型故障的恢复策略

## 事务处理

事务：访问并可能更新数据库上数据的一个程序执行单元(unit)

在关系数据库系统中，一个事物是由一条SQL语句或者一组SQL语句所构成的一个执行过程，并具有ACID四个特性

事务是恢复和并发控制的基本单位

**事务**：某个用户执行的一个不能被打断的对数据库的操作序列

四条ACID性质：
* 原子性Atomicity：一个事务中的操作要么全部执行结束，要么一个都不执行。数据库管理系统会通过**事务管理子系统**、事务日志自动维护原子性
* 一致性Consistency：一个事务的成功执行总是将数据库从一个一致的状态转移到另一个一致的状态，包括了数据库中显式定义的各种完整性约束与用户心目中的隐式数据约束，可以通过DBMS的**数据完整性保护子系统**和编写事务的应用程序员两方面进行保护
* 隔离性 Isolation：一个事务的执行与并发执行的其他事务独立，互不干扰，由**并发控制子系统**实现
* 持久性 Durability：一个事务完成操作后，对数据库的更新永久反映在数据库中，即使以后故障也能通过故障恢复保留结果，由DBMS的**恢复管理子系统**实现

### 事务活动的流程

**活动**状态：事务开始执行后，进入活动状态，事务将执行数据库的访问操作，对于读操作，将数据读入用户的私有工作区间，如果该数据当前不存在DBMS系统缓冲区，那么DBMS首先将该数据从磁盘读入系统缓冲区，再将其拷贝到用户事务的私有工作区。对于写操作，可能并不是立即将数据永久写入磁盘，可能会暂时存放在DBMS系统缓冲区。

**预提交**状态：事务最后一个访问语句执行结束后，事务进入预提交状态，此时写操作的结果可能还在缓冲区内，要确保当前事务的所有修改操作都真正被写入数据库的磁盘中，当所有写磁盘操作执行结束后，进入**提交**状态，否则如果执行过程中发生故障导致执行失败猫就进入**失败**状态

**失败**(abort)状态：事务执行完最后一条语句前中断或者预提交失败都会进入失败状态，原因可能是用户或应用程序主动放弃，因为并发控制被放弃(如封锁申请超时等待、死锁)或者发生系统故障

**异常中止**(aborted)状态:对于失败状态事务，可能已经进行了一部分修改，为保证原子性，需要撤销已经进行的修改(回退rollback，由DBMS的恢复子系统实现)，进入**异常中止**状态，此时系统可以取消事务，也可以作为一个新的事务重新启动。

**提交**状态：进入预提交后，并发控制子系统检查是否发生干扰，检查通过后执行提交操作，执行后进入提交状态

### 有关事务的语句

主要有三条语句：
* 事务的开始(begin transaction): 事务的启动是隐式的，可以通过三种方式启动一个新的事务：数据定义命令DDL(每一条数据定义命令作为一个单独事务执行，在此之前当前用户事务自动提交)，将系统设置为自动提交方式即打开自动提交标志(每一条数据库访问指令都将作为一个单独的事务执行并根据执行结果自动提交或者回退)，数据操纵命令DML(前一个事务执行结束后，下一个数据访问操作执行之前，自动为用户启动一个新的事务)。 
* 提交事务(commit transaction):提交可能因为系统故障或者数据完整性检查而导致失败，事务提交失败后可以通过回退来取消当前事务，系统自动提交的事务将会自动进行回退操作
* 回退事务(rollback transaction):取消事务执行过程中的所有操作，回滚至起点，在事务执行过程中，用户可以设置若干**保存点(savepoint)**,用户事务可以使用rollback回滚到某一个保存点并继续执行当前事务，不带保存点的回退将结束并放弃整个事务

设置事务的自动提交：
`SET AUTOCOMMIT ON|OFF`

设置事务的类型（只读型事务与读/写型事务，缺省定义为读/写型事务）：
`SET TANSACTION READONLY | READWRITE`

设置事务的隔离级别：
```SQL
SET  TRANSACTION  ISOLATION  LEVEL
	READUNCOMMITTED
  | READCOMMITTED
  | READREPEATABLE 
  | SERIALIZABLE
```
设置了不同的隔离级别，系统所采取的封锁策略也不同
* 未提交读：不申请封锁，可能读到未提交结果，禁止以此方式执行写操作
* 提交读：读数据A前申请对A的**共享性**封锁，读结束后立即释放该封锁
* 可重复读：读数据A前申请对A的**共享性**封锁并将封锁维持到事务结束
* 可序列化(可串行化)：以一种可串行化的调度策略实现并并发执行，以避免干扰现象

但是不管设置了何种隔离级别，在写数据对象A的时候，会申请对A的**排他性**封锁并维持到事务结束

### 事务的组成

数据对象：
* 数据对象的大小：可以是一个属性值/元组/表/整个数据库，我们不严格区分只是称为数据对象A
* 数据对象的地址空间：存在三种有关的地中空间概念(保存数据的磁盘空间、内润缓冲区、事务的局部地址空间即内存变量)

一个事务有关的操作分为两类：
* 事务控制操作（其中T0为事务标识符，每启动一个事务，DBMS自动分配一个唯一的事务标识符）
  * 事务的开始：START T0
  * 提交事务：COMMIT T0
  * 回退(放弃事务)： ABORT T0
* 数据访问操作：
  * INPUT(A)：将数据A从磁盘读入内存缓冲区
  * OUTPUT(A)：将数据A从内存缓冲区写入磁盘
  * READ(A,t)：将内存缓冲区的数据对象A的值读入内存变量t(可能包含INPUT操作)
  * WRITE(A,t) ：将内存变量的值写入对象A

## 并发控制技术

### 事务的并发执行

并发控制技术：实现多个用户事务的并发执行

并发执行的可串行化: 一组事务并发执行的结果等价于他们之间的某种串行执行的结果，称为**可串行化调度**

并发控制的目标就是要实现并发事务的可串行化调度

各个事务的数据库访问操作在DBMS中的实际执行序列构成了事务之间的一个**调度**，一组事务的调度必须包括所有操作包括一个事务的结束命令，且保证单个事务内部执行顺序不变

值得注意的是，不同事务的访问请求在DBMS内部的执行顺序可能与到达顺序不一样，但是同一个事务内部的操作顺序一定与到达顺序一致

串行调度：首先是一个事务的所有操作，然后是另一个事务的所有操作，依次类推，称调度是串行的

我们用符号 $T_1,T_2..$ 标识事务，用$r_i(X)$标识事务$T_i$读数据库对象X，类似的有$w_i(x)$ 

冲突：调度中的一对相邻操作(op1,op2)如果交换他们的顺序，那么涉及的事务中至少有一个的行为会改变，那么称这对相邻操作为**冲突**

冲突包括：同一个事务的任意两个相邻操作，对于不同事务的两个相邻操作中涉及同一对象且至少有一个为写操作

如果对于初始给定的一个调度，可以通过一组非冲突化操作变成一个串行调度，那么认为最初的调度是一个可串行化调度且称为**冲突可串行化调度**

注意：冲突可串行化调度一定是一个可串行化调度，但是**可串行化调度不一定是一个冲突可串行化的**

如果两个事务$T_1,T_2$分别存在动作$A_1,A_2$,在调度H中，$A_1$在$A_2$之前执行，如果两个动作涉及同一个数据对象并且至少有一个为写动作，那么称$T_1$优先于$T_2$,记为$T_1 <_S T_2$,上述情况下，A1与A2不能交换，在H的冲突等价串行调度中，T1必在T2之前

**判断是否冲突可串行化**：如果$T_i <_S T_j$,那么从i到j引一条有向边，如此寻找所有冲突对(可以根据所有被访问的数据对象来发现冲突对)构造优先图，如果事务优先图中无环，则为冲突可串行化调度，否则不是。

利用优先图，如果一个点不存在指向该节点的有向边，就先执行这个节点对应的事务，再考虑其他节点的优先图。

三种可串行化调度：视图可串行化是可串行化调度的子集，冲突可串行化是视图可串行化的子集

视图可串行化调度指的是**视图等价**为一个串行调度，S与H视图等价当且仅当满足以下三个条件：对每一个数据项D
* 如果在调度S中事务Tk读到D的初始值，则在调度H中事务Tk也必须读到D的初始值；
* 如果在调度S中事务Tk执行了$r_k(D)$，并且读到的是由事务Tj写入的D的值，则在调度H中事务Tk的$r_k(D)$读到的也必须是由事务Tj 所写入的D的值；
* 如果在调度S中是由事务Tk来执行最后一条关于D的写操作$w_k(D)$，则在调度H中也一定是事务Tk执行最后一条关于D的写操作$w_k(D)$。

视图可串行化调度不一定是冲突可串行化调度的原因在于：可能存在盲写现象(一个事务没有读取数据项D的值并直接用write操作修改D的值)

数据不一致现象：
* 丢失修改(lost-update)：一个事务的修改破坏了另一个事务的修改结果，原因在于对多个并发修改同一个值没有限制
* 脏读（dirty-read）：一个事务读到了另一个事务未提交的结果
* 不可重复读(unrepeatable-read):在两次读操作之间差入了另一个事务的写操作
  
### 封锁

封锁一段事件内禁止其他事务执行某些操作同时也表明持有该封锁的事务在被封锁的数据对象上执行什么样的操作

**排他锁：X锁**：只有在数据A上没有任何封锁的时候能申请，如果一个事务申请了X锁，那么其他事务都不能获得A上的任何类型的封锁，获得X锁后可以进行读、写操作，其他事务禁止访问，降低了并行性，但是保证了正确性与一致性，X锁必须维持到事务结束

**共享锁：S锁**： 如果数据A没有被封锁或者是以S锁的形式封锁时，可以申请S锁，事务T可以读，**但是不可以写**，S锁不一定要维持到事务结束

合适事务：一个事务访问前按照要求申请封锁，操作结束后释放封锁，这种事务称为合适事务

合适事务时保证并发事件正确执行的基本条件

封锁管理器的数据结构：数组LOCK(A)记录数据对象A上的封锁状态，分别是Read_locked(共享锁)、Write_locked(排他锁)、Unlocked(无封锁)，数组no_of_reads(A)记录A上的共享锁的个数。

基于封锁技术的并发控制实现方法：
* 在DBMS的**封锁管理器**上维护一张锁表，包括了封锁的持有情况(哪些事务在哪些数据对象上持有什么锁)与封锁的申请等待情况(有哪些事务正在等待哪些数据对象上的什么类型的封锁)
* DBMS对于请求op(A)，将访问操作发送给并发控制子系统的**调度器**。调度器根据系统的**封锁协议**来决定是否需要为该操作申请封锁以及申请何种类型的封锁，并将封锁请求发送给**封锁管理器**，封锁管理器根据锁表的情况决定能够立即满足，并将结果返回给**调度器**，如果得不到满足，则**调度器**将访问操作放入被推迟的访问操作序列，否则将该操作发送给系统的执行引擎去执行。

### 封锁协议

封锁协议规定了何时申请封锁，申请何种类型封锁，何时释放封锁

最常见的有**三级封锁协议**与**两阶段封锁协议**


