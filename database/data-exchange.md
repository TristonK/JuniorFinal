# 游标管理与索引

> 游标管理
>
> * 游标的作用
> * 游标的定义、打开、使用、关闭
> * 可滚动游标的定义及其在数据更新命令中的使用
>
> 索引 \(index\)
>
> * B+索引的数据结构，搜索算法

## 游标管理

游标的定义\(declare a cursor\):为某一映像语句（可能返回多个结果元组）的结果集合定义一个命名的游标

```sql
EXEC SQL DECLARE cursor-name CURSOR FOR
    subquery
    [ ORDER BY ...... ]
    [ FOR { READ ONLY |
           UPDATE [ OF columnname, ...... ] } ] ;
```

游标的打开\(open the cursor\):执行相应的映像语句并打开获得的结果集，此时游标处于活动状态并指向结果集合的第一条记录的前面

```sql
EXEC  SQL  OPEN  cursor-name ;
```

游标的使用\(fetch a row by the cursor\):将游标推向结果集合中的下一条记录，读出游标所指向记录的值并赋给对应的主语言变量，举例如下：

```sql
/*其中agent_dollors是游标名，前带：的是表示主语言定义的变量*/
exec  sql  fetch agent_dollars
                     into :agent_id, :dollar_sum;
```

每一个fetch的下一个是随机的（如果没有order by的话），所以每一个被打开过的游标只能遍历一次\(但是可以打开多次\)

游标的关闭\(close the cursor\):关闭所使用的游标，释放相关的系统资源

```sql
EXEC  SQL  CLOSE  cursor-name ;
```

游标一旦被定义\(declare\)，可以被重复使用\(open-fetch-close\)。每一次open一个游标，都将重新执行对应的query，并生成新的结果集。

应用程序可以通过‘游标状态变量’来了解一个游标的当前状态\(是否处于打开状态、结果元组的个数、是否fetch到结果元组...

可滚动游标的定义:

```sql
EXEC  SQL  DECLARE  cursor_name
[ INSENSITIVE ]  [ SCROLL ]
CURSOR  [ WITH  HOLD ]  FOR
subquery  { UNION  subquery }
[ ORDER  BY ...... ]
[ FOR  READ  ONLY  |
FOR  UPDATE  OF  columnname ...... ];
```

可滚动游标的更新：

```sql
EXEC  SQL  FETCH
[ { NEXT | PRIOR | FIRST | LAST |
{ ABSOLUTE | RELATIVE } value_spec } FROM ]
cursor_name INTO ......;
```

## 索引

顺序文件：按照某个属性的取值进行排序的而构成的数据文件

索引文件：为了加快数据文件的检索速度，根据用于定义查询条件的属性（索引关键字）来建立索引文件。由一个索引关键字值k\_val和一个元组指针t\_ptr所构成的二元组称为索引项

为数据文件中的每个元组都生成一个索引项，由与某个数据文件相关的所有索引项而组成的文件被称为索引文件

索引的查找：在索引文件中按照特征字段的值进行查找，找到具有该特征的记录的记录指针，从而可以在数据文件中直接定位读出需要的记录

### 顺序文件上的索引

如果索引属性的值唯一，采取前三种，否则采取最后一种

#### 稠密索引

#### 稀疏索引

#### 多级索引

#### 具有重复键值的索引

### B/B+树上索引文件

树的最下一级索引是叶节点

B+树的特点：

* 平衡性：根节点到每个叶节点的路径等长
* 过半性：除根节点之外每个节点所对应的磁盘空间至少被占用一半
* 顺序性：既可以从根节点开始随机查找关键字，也可以根据索引关键字的值进行排序进行顺序访问
* 自适应性：自动保持与数据文件大小相适应的索引层次

B+树的节点：每个节点占用一个磁盘块，每棵B+树有一个称为**秩**的整形参数n，每个结点可以容纳n个键和n+1个指针。

结点的内容：$P_1,K\_1,P\_2,K\_2,..,P\_m,K\_m,P_{m+1}$,其中K为关键字值，且关键字按照从小到大的顺序进行排列

* 根节点：$P_1$到$P_{m+1}$分别指向另一棵子树根节点
* 叶节点：前m个指针指向数据，最后一个指针指向右边的下一个叶子节点
* 非叶节点：对于夹在关键字$K_i$与$K_{i+1}$之间的那个指针，其指向的子树的键值都满足$K_i&lt;K&lt;K_{i+1}$

B+树上的随机查找：输入关键字K，根据节点的性质进行比较找到叶节点，判断叶节点中是否有关键字

B+树上的范围查找：输入范围\[a,b\],先按照上述算法找到a对应的叶子节点，然后对叶子节点中的每个值与b进行对比直到大于b为止，这个叶节点中都小于b那么利用指向下一个叶节点的指针在下一个叶结点中重复上述判断

